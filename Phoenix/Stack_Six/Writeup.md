# Challenge Source Code
```
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
    "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *what = GREET;

char *greet(char *who) {
    char buffer[128];
    int maxSize;

    maxSize = strlen(who);
    if (maxSize > (sizeof(buffer) - /* ensure null termination */ 1)) {
    maxSize = sizeof(buffer) - 1;
}

    strcpy(buffer, what);
    strncpy(buffer + strlen(buffer), who, maxSize);

    return strdup(buffer);
}

int main(int argc, char **argv) {
    char *ptr;
    printf("%s\n", BANNER);

#ifdef NEWARCH
    if (argv[1]) {
        what = argv[1];
    }
#endif

    ptr = getenv("ExploitEducation");
    if (NULL == ptr) {
    // This style of comparison prevents issues where you may accidentally
    // type if(ptr = NULL) {}..

    errx(1, "Please specify an environment variable called ExploitEducation");
    }

    printf("%s\n", greet(ptr));
    return 0;
}
```
# Challenge Theory
This is another basic buffer overflow.
This time it uses strcpy instead of instead of gets.
There are also a few other things added to the buffer.
# Working on the Challenge
Setting the environment variable "ExploitEducation" outside of gdb will be done.
This way the env can be set with scripts.
Also the "GREET" macro simply creates the string "Welcome, I am pleased to meet you".
Currently using string from the range 128 to 144 bytes in length to get the "greet" function to return garbage values into the $rip register.
136 bytes specifically causes the 0x0 to be put into $rip, but anything larger will end up putting some kind of random address into $rip.
The values are not useful, and do not yield much info into what is going with the program.
They do have something to do with the return of strdup, or strcpy. 
## Variables
```
gdb based buffer address = 0x7fffffffe568
0x7fffffffe568 = 140737488348520
0x7fffffffe560 = 140737488348512
rbp value = 0x7fffffffe610

```
