# Challenge Source Code
```
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
"Welcome to " LEVELNAME ", brought to you by https://exploit.education"

int changeme;

void bounce(char *str) {
    printf(str);
}

int main(int argc, char **argv) {
    char buf[256];

    printf("%s\n", BANNER);

    if (argc > 1) {
        memset(buf, 0, sizeof(buf));
        strncpy(buf, argv[1], sizeof(buf));
        bounce(buf);
    }

    if (changeme != 0) {
        puts("Well done, the 'changeme' variable has been changed correctly!");
    } else {
        puts("Better luck next time!\n");
    }

    exit(0);
}
```
# Challenge Theory
This challenge is extremely similar to other fmt string challenges, except for the fact that instead of a stack value, it is now a global variable which must be changed.
After taking a look at a debugger, the "changeme" variable is located at the memory address 0x600af0.
This value is not conviently close to the stack, therefore modifying that specific value in memory must be modified directly instead of overflowing the stack like other vulns. 
# Working on the Challenge
There are also different solutions required for different architectures.
This writeup will contain them both.
A few things are needed to solve this challenge.
First, where values actually get placed onto the stack is required.
